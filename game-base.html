<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Cobrinha</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
        }
        #gameCanvas {
            border: 8px solid #4a5568;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), 0 6px 6px rgba(0,0,0,0.25);
        }
        .btn-control, .shop-btn {
            transition: all 0.1s ease-in-out;
        }
        .btn-control:active, .shop-btn:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .shop-item-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #cbd5e0;
        }
        .tab-btn {
            border-bottom: 4px solid transparent;
        }
        .tab-btn.active {
            border-bottom-color: #f6e05e;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-lg mx-auto text-center relative">
        <h1 class="text-4xl md:text-5xl font-bold mb-2 text-green-400 tracking-wider">SNAKE</h1>
        <div class="flex justify-between items-center bg-gray-800 p-3 rounded-lg shadow-lg mb-4 text-sm md:text-base">
            <div class="flex items-center space-x-2">
                <svg width="24" height="24" viewBox="0 0 100 100"><path d="M85,50 C85,30 75,15 60,15 C45,15 35,30 35,50 C35,70 45,85 60,85 C75,85 85,70 85,50" fill="#e53e3e"/><path d="M65,50 C65,30 55,15 40,15 C25,15 15,30 15,50 C15,70 25,85 40,85 C55,85 65,70 65,50" fill="#c53030"/><path d="M50,15 C55,5 65,5 70,15" stroke="#48bb78" stroke-width="8" fill="none" stroke-linecap="round"/></svg>
                <span id="totalRedAppleScore" class="font-bold text-yellow-400">0</span>
            </div>
            <div class="flex items-center space-x-2">
                <svg width="24" height="24" viewBox="0 0 100 100"><path d="M85,50 C85,30 75,15 60,15 C45,15 35,30 35,50 C35,70 45,85 60,85 C75,85 85,70 85,50" fill="#f6e05e"/><path d="M65,50 C65,30 55,15 40,15 C25,15 15,30 15,50 C15,70 25,85 40,85 C55,85 65,70 65,50" fill="#f6ad55"/><path d="M50,15 C55,5 65,5 70,15" stroke="#48bb78" stroke-width="8" fill="none" stroke-linecap="round"/></svg>
                <span id="goldenScore" class="font-bold text-yellow-400">0</span>
            </div>
            <button id="restartButton" class="bg-green-500 hover:bg-green-600 text-gray-900 font-bold py-2 px-4 rounded-md">REINICIAR</button>
        </div>
        
        <div class="flex justify-center items-start space-x-4">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <!-- Barra de Multiplicador -->
            <div class="flex flex-col items-center justify-between h-[400px] py-2 text-xs">
                <span>2x</span>
                <div class="w-6 h-full bg-gray-700 rounded-full overflow-hidden flex flex-col-reverse border-2 border-gray-600">
                    <div id="multiplierBarFill" class="w-full bg-green-500" style="height: 0%;"></div>
                </div>
                 <span>1x</span>
            </div>
        </div>


        <div id="gameOverMessage" class="hidden absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4">
            <h2 class="text-3xl sm:text-5xl text-red-500 font-bold">FIM DE JOGO</h2>
            <p class="text-xl sm:text-2xl mt-4">Maçãs nesta partida: <span id="finalScore">0</span></p>
            <button id="restartButtonGameOver" class="mt-8 bg-green-500 hover:bg-green-600 text-gray-900 font-bold py-2 px-4 rounded-md">JOGAR NOVAMENTE</button>
            <button id="shopButton" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md">LOJA</button>
        </div>

        <div id="shopMenu" class="hidden absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-start items-center text-center p-4">
            <div class="w-full flex justify-center border-b-2 border-gray-700 mb-4">
                <button id="skinsTabButton" class="tab-btn text-xl font-bold p-2 w-1/2">SKINS</button>
                <button id="upgradesTabButton" class="tab-btn text-xl font-bold p-2 w-1/2">UPGRADES</button>
            </div>
            <div id="skinsContent" class="w-full space-y-3 overflow-y-auto max-h-64"></div>
            <div id="upgradesContent" class="hidden w-full space-y-3 overflow-y-auto max-h-64"></div>
            <button id="backToGameOverButton" class="mt-auto bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md">VOLTAR</button>
        </div>
    </div>

    <div class="mt-6 grid grid-cols-3 gap-3 w-48 md:hidden">
        <div></div><button id="upBtn" class="btn-control bg-gray-700 p-4 rounded-lg shadow-md"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg></button><div></div>
        <button id="leftBtn" class="btn-control bg-gray-700 p-4 rounded-lg shadow-md"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
        <button id="downBtn" class="btn-control bg-gray-700 p-4 rounded-lg shadow-md"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg></button>
        <button id="rightBtn" class="btn-control bg-gray-700 p-4 rounded-lg shadow-md"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const totalRedAppleScoreElement = document.getElementById('totalRedAppleScore');
        const goldenScoreElement = document.getElementById('goldenScore');
        const restartButton = document.getElementById('restartButton');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButtonGameOver = document.getElementById('restartButtonGameOver');
        const shopButton = document.getElementById('shopButton');
        const shopMenu = document.getElementById('shopMenu');
        const backToGameOverButton = document.getElementById('backToGameOverButton');
        const skinsTabButton = document.getElementById('skinsTabButton');
        const upgradesTabButton = document.getElementById('upgradesTabButton');
        const skinsContent = document.getElementById('skinsContent');
        const upgradesContent = document.getElementById('upgradesContent');
        const multiplierBarFill = document.getElementById('multiplierBarFill');

        const gridSize = 20;
        let maxFoods = 2;
        let snake = [], foods = [], obstacles = [];
        let dx = 0, dy = 0, sessionRedAppleCount = 0, totalRedApples = 0, totalGoldenPoints = 0;
        let changingDirection = false, gameLoop, isGameOver = false, currentSkin, upgrades = {};
        
        let runMultiplier = 1.0;
        let growthSinceMultiplierIncrease = 0;
        let obstacleSpawnTimer = null;

        const skins = [
            { id: 'green', name: 'Verde Clássico', head: '#48bb78', body: '#38a169', cost: 0 },
            { id: 'blue', name: 'Azul Elétrico', head: '#4299e1', body: '#3182ce', cost: 10 },
            { id: 'purple', name: 'Roxo Real', head: '#9f7aea', body: '#805ad5', cost: 100 },
            { id: 'orange', name: 'Laranja Atômico', head: '#f6ad55', body: '#ed8936', cost: 1000 }
        ];

        const upgradeData = {
            appleValue: { name: 'Maçã Nutritiva', desc: 'Ganha +1 maçã vermelha por coleta.', maxLevel: 10, cost: level => Math.floor(75 * Math.pow(1.8, level)), type: 'red' },
            maxApples: { name: 'Cesta Maior', desc: 'Aumenta o nº de maçãs no mapa.', maxLevel: 5, cost: level => Math.floor(200 * Math.pow(1.9, level)), type: 'red' },
            magnetChance: { name: 'Sorte Magnética', desc: 'Aumenta a chance do Íman de 1% para 5%.', maxLevel: 1, cost: () => 200, type: 'golden' }
        };

        function startGame() {
            loadSavedData();
            maxFoods = 2 + (upgrades.maxApples ? upgrades.maxApples.level : 0);
            snake = [ { x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 } ];
            dx = 0; dy = 0; sessionRedAppleCount = 0; isGameOver = false; changingDirection = false;
            runMultiplier = 1.0; growthSinceMultiplierIncrease = 0;
            updateMultiplierBar();
            gameOverMessage.classList.add('hidden'); shopMenu.classList.add('hidden');
            foods = []; obstacles = [];
            
            clearInterval(obstacleSpawnTimer);
            
            for(let i = 0; i < maxFoods; i++) spawnNewFood();
            obstacleSpawnTimer = setInterval(trySpawnObstacle, 15000);
            
            drawInitialState();

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(main, 150);
        }
        
        function drawInitialState() { clearCanvas(); drawFoods(); drawObstacles(); drawSnake(); }
        function main() { if (isGameOver) return; changingDirection = false; clearCanvas(); drawFoods(); drawObstacles(); moveSnake(); drawSnake(); checkCollision(); }

        function clearCanvas() {
            const darkColor = '#1a202c', lightColor = '#2d3748';
            for (let x = 0; x < canvas.width / gridSize; x++) {
                for (let y = 0; y < canvas.height / gridSize; y++) {
                    ctx.fillStyle = ((x + y) % 2 === 0) ? darkColor : lightColor;
                    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }
        }

        function drawSnake() {
            ctx.strokeStyle = currentSkin.body; ctx.lineWidth = gridSize - 6; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(snake[0].x * gridSize + gridSize / 2, snake[0].y * gridSize + gridSize / 2);
            for (let i = 1; i < snake.length; i++) {
                const current = snake[i], previous = snake[i - 1];
                if (Math.abs(current.x - previous.x) > 1 || Math.abs(current.y - previous.y) > 1) {
                    ctx.stroke(); ctx.beginPath(); ctx.moveTo(current.x * gridSize + gridSize / 2, current.y * gridSize + gridSize / 2);
                } else { ctx.lineTo(current.x * gridSize + gridSize / 2, current.y * gridSize + gridSize / 2); }
            }
            ctx.stroke(); drawHead();
        }

        function drawHead() {
            const head = snake[0], x = head.x * gridSize, y = head.y * gridSize, radius = gridSize / 2;
            ctx.fillStyle = currentSkin.head; ctx.beginPath(); ctx.arc(x + radius, y + radius, radius - 2, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = 'white'; const eyeRadius = 3; let eye1X, eye1Y, eye2X, eye2Y;
            let eyeDirection = (dx !== 0 || dy !== 0) ? {dx, dy} : {dx: 1, dy: 0};
            if (eyeDirection.dx === 1) { eye1X = x + gridSize - 6; eye1Y = y + 6; eye2X = x + gridSize - 6; eye2Y = y + gridSize - 6; } 
            else if (eyeDirection.dx === -1) { eye1X = x + 6; eye1Y = y + 6; eye2X = x + 6; eye2Y = y + gridSize - 6; } 
            else if (eyeDirection.dy === 1) { eye1X = x + 6; eye1Y = y + gridSize - 6; eye2X = x + gridSize - 6; eye2Y = y + gridSize - 6; } 
            else { eye1X = x + 6; eye1Y = y + 6; eye2X = x + gridSize - 6; eye2Y = y + 6; }
            ctx.beginPath(); ctx.arc(eye1X, eye1Y, eyeRadius, 0, 2 * Math.PI); ctx.arc(eye2X, eye2Y, eyeRadius, 0, 2 * Math.PI); ctx.fill();
        }

        function moveSnake() {
            if (dx === 0 && dy === 0) return;
            const head = { x: snake[0].x + dx, y: snake[0].y + dy }, gridWidth = canvas.width / gridSize, gridHeight = canvas.height / gridSize;
            if (head.x < 0) head.x = gridWidth - 1; else if (head.x >= gridWidth) head.x = 0;
            if (head.y < 0) head.y = gridHeight - 1; else if (head.y >= gridHeight) head.y = 0;
            snake.unshift(head);
            let ateFood = false;
            for (let i = foods.length - 1; i >= 0; i--) {
                if (head.x === foods[i].x && head.y === foods[i].y) {
                    handleFoodConsumption(i);
                    ateFood = true;
                }
            }
            if (!ateFood) snake.pop();
        }

        function handleFoodConsumption(foodIndex) {
            const food = foods[foodIndex];
            
            if (food.type === 'magnet') {
                foods.splice(foodIndex, 1);
                const otherFoods = [...foods];
                foods = [];
                otherFoods.forEach(f => {
                    snake.push({ ...snake[snake.length - 1] });
                    consume(f);
                });
            } else {
                foods.splice(foodIndex, 1);
                if (food.type !== 'shrink') {
                    snake.push({ ...snake[snake.length - 1] });
                }
                consume(food);
            }
            
            while (foods.length < maxFoods) {
                spawnNewFood();
            }
        }

        function consume(food) {
            growthSinceMultiplierIncrease++;
            switch(food.type) {
                case 'red':
                    let value = (1 + (upgrades.appleValue ? upgrades.appleValue.level : 0)) * runMultiplier;
                    sessionRedAppleCount++;
                    totalRedApples += value;
                    saveRedApples();
                    break;
                case 'golden':
                    totalGoldenPoints++;
                    saveGoldenPoints();
                    break;
                case 'shrink':
                    growthSinceMultiplierIncrease--; // Shrinking doesn't count as growth
                    if (snake.length > 3) {
                        const toRemove = Math.min(3, snake.length - 3);
                        for(let i=0; i<toRemove; i++) snake.pop();
                    }
                    break;
            }
            if (growthSinceMultiplierIncrease >= 3) {
                if (runMultiplier < 2.0) {
                    runMultiplier = Math.min(2.0, runMultiplier + 0.05);
                    updateMultiplierBar();
                }
                growthSinceMultiplierIncrease = 0;
            }
        }
        
        function updateMultiplierBar() {
            const percentage = ((runMultiplier - 1) / (2 - 1)) * 100;
            multiplierBarFill.style.height = `${percentage}%`;
        }

        function spawnNewFood() {
            let newFood = {};
            const chance = Math.random();
            const magnetChance = (upgrades.magnetChance && upgrades.magnetChance.level > 0) ? 0.05 : 0.01;

            if (chance < magnetChance) newFood.type = 'magnet';
            else if (chance < magnetChance + 0.03) newFood.type = 'shrink';
            else if (chance < magnetChance + 0.03 + 0.1) newFood.type = 'golden';
            else newFood.type = 'red';

            while (true) {
                newFood.x = Math.floor(Math.random() * (canvas.width / gridSize));
                newFood.y = Math.floor(Math.random() * (canvas.height / gridSize));
                if (!snake.some(p => p.x === newFood.x && p.y === newFood.y) && !foods.some(f => f.x === newFood.x && f.y === newFood.y)) break;
            }
            foods.push(newFood);
        }

        function drawFoods() { 
            const colorMap = { red: '#e53e3e', golden: '#f6e05e', shrink: '#d6bcfa', magnet: '#fefcbf' };
            foods.forEach(f => drawApple(f, colorMap[f.type])); 
        }
        function drawApple(food, color) {
            const x = food.x * gridSize, y = food.y * gridSize, radius = gridSize / 2;
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x + radius, y + radius, radius - 2, 0, 2 * Math.PI); ctx.fill();
            if (food.type !== 'magnet') {
                ctx.fillStyle = '#48bb78'; ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + radius + 4, y + 4); ctx.lineTo(x + radius + 8, y + 2); ctx.fill();
            }
        }
        
        function trySpawnObstacle() {
            if (obstacles.length > 0) return;
            let obstacle = {};
            const gridWidth = canvas.width / gridSize;
            const gridHeight = canvas.height / gridSize;

            while (true) {
                let isOccupied = false;
                obstacle.x = Math.floor(Math.random() * (gridWidth - 2));
                obstacle.y = Math.floor(Math.random() * (gridHeight - 2));
                
                for(let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const checkX = obstacle.x + i;
                        const checkY = obstacle.y + j;
                        if (snake.some(p => p.x === checkX && p.y === checkY) || foods.some(f => f.x === checkX && f.y === checkY)) {
                            isOccupied = true;
                            break;
                        }
                    }
                    if(isOccupied) break;
                }
                if (!isOccupied) break;
            }
            
            obstacle.state = 'green';
            obstacle.parts = [];
            for(let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                   obstacle.parts.push({x: obstacle.x + i, y: obstacle.y + j});
                }
            }
            obstacles.push(obstacle);

            setTimeout(() => { obstacle.state = 'yellow'; }, 4000);
            setTimeout(() => { obstacle.state = 'red'; }, 7000);
            setTimeout(() => {
                const idx = obstacles.indexOf(obstacle);
                if (idx > -1) obstacles.splice(idx, 1);
            }, 17000);
        }

        function drawObstacles() {
            const stateColors = {
                green: 'rgba(72, 187, 120, 0.5)',
                yellow: 'rgba(246, 224, 94, 0.6)',
                red: '#a0aec0'
            };

            obstacles.forEach(obs => {
                ctx.fillStyle = stateColors[obs.state];
                ctx.strokeStyle = '#4a5568';
                obs.parts.forEach(part => {
                    ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    if (obs.state === 'red') {
                        ctx.strokeRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    }
                });
            });
        }

        function saveRedApples() { localStorage.setItem('snakeRedApples', totalRedApples); totalRedAppleScoreElement.textContent = totalRedApples.toFixed(1); }
        function saveGoldenPoints() { localStorage.setItem('snakeGoldenPoints', totalGoldenPoints); goldenScoreElement.textContent = totalGoldenPoints; }
        function saveUpgrades() { localStorage.setItem('snakeUpgrades', JSON.stringify(upgrades)); }

        function loadSavedData() {
            totalRedApples = parseFloat(localStorage.getItem('snakeRedApples')) || 0;
            totalGoldenPoints = parseInt(localStorage.getItem('snakeGoldenPoints')) || 0;
            totalRedAppleScoreElement.textContent = totalRedApples.toFixed(1);
            goldenScoreElement.textContent = totalGoldenPoints;
            const equippedSkinId = localStorage.getItem('snakeEquippedSkin') || 'green';
            currentSkin = skins.find(s => s.id === equippedSkinId);
            upgrades = JSON.parse(localStorage.getItem('snakeUpgrades')) || {};
        }

        function populateShopSkins() {
            skinsContent.innerHTML = '';
            const purchasedSkins = JSON.parse(localStorage.getItem('snakePurchasedSkins')) || ['green'];
            const equippedSkinId = localStorage.getItem('snakeEquippedSkin') || 'green';
            skins.forEach(skin => {
                const isPurchased = purchasedSkins.includes(skin.id), isEquipped = skin.id === equippedSkinId;
                const itemDiv = document.createElement('div'); itemDiv.className = 'flex items-center justify-between bg-gray-800 p-2 rounded-lg';
                const previewDiv = document.createElement('div'); previewDiv.className = 'shop-item-preview'; previewDiv.style.backgroundColor = skin.head; previewDiv.style.border = `3px solid ${skin.body}`;
                const nameSpan = document.createElement('span'); nameSpan.textContent = skin.name; nameSpan.className = 'text-xs';
                const button = document.createElement('button'); button.className = 'shop-btn text-xs font-bold py-2 px-3 rounded-md';
                if (isEquipped) { button.textContent = 'EQUIPADO'; button.disabled = true; button.className += ' bg-gray-500'; } 
                else if (isPurchased) { button.textContent = 'EQUIPAR'; button.className += ' bg-green-500 hover:bg-green-600'; button.onclick = () => { localStorage.setItem('snakeEquippedSkin', skin.id); populateShopSkins(); }; } 
                else {
                    button.innerHTML = `COMPRAR <span class="text-yellow-300">${skin.cost}</span>`;
                    if (totalGoldenPoints >= skin.cost) {
                        button.className += ' bg-yellow-500 hover:bg-yellow-600';
                        button.onclick = () => { if(totalGoldenPoints >= skin.cost) { totalGoldenPoints -= skin.cost; saveGoldenPoints(); purchasedSkins.push(skin.id); localStorage.setItem('snakePurchasedSkins', JSON.stringify(purchasedSkins)); populateShopSkins(); } };
                    } else { button.className += ' bg-gray-600 opacity-50'; button.disabled = true; }
                }
                itemDiv.append(previewDiv, nameSpan, button); skinsContent.appendChild(itemDiv);
            });
        }

        function populateUpgrades() {
            upgradesContent.innerHTML = '';
            Object.keys(upgradeData).forEach(key => {
                const upgrade = upgradeData[key];
                const currentLevel = upgrades[key] ? (upgrades[key].level || 0) : 0;
                const isMaxed = currentLevel >= upgrade.maxLevel;
                const cost = isMaxed ? 0 : upgrade.cost(currentLevel);
                const itemDiv = document.createElement('div'); itemDiv.className = 'flex items-center justify-between bg-gray-800 p-2 rounded-lg text-left';
                const infoDiv = document.createElement('div'); infoDiv.className = 'flex flex-col';
                const nameSpan = document.createElement('span'); nameSpan.textContent = `${upgrade.name} (Nvl ${currentLevel}/${upgrade.maxLevel})`;
                const descSpan = document.createElement('span'); descSpan.className = 'text-xs text-gray-400'; descSpan.textContent = upgrade.desc;
                infoDiv.append(nameSpan, descSpan);
                const button = document.createElement('button'); button.className = 'shop-btn text-xs font-bold py-2 px-3 rounded-md';
                if (isMaxed) { button.textContent = 'MAX'; button.disabled = true; button.className += ' bg-gray-500'; } 
                else {
                    const currency = upgrade.type === 'red' ? totalRedApples : totalGoldenPoints;
                    const currencyColor = upgrade.type === 'red' ? 'text-red-400' : 'text-yellow-300';
                    button.innerHTML = `UPGRADE <span class="${currencyColor}">${cost.toFixed(0)}</span>`;
                    if (currency >= cost) {
                        button.className += ' bg-blue-500 hover:bg-blue-600';
                        button.onclick = () => {
                            if (currency >= cost) {
                                if (upgrade.type === 'red') { totalRedApples -= cost; saveRedApples(); } 
                                else { totalGoldenPoints -= cost; saveGoldenPoints(); }
                                if (!upgrades[key]) upgrades[key] = { level: 0 };
                                upgrades[key].level = currentLevel + 1;
                                saveUpgrades();
                                populateUpgrades();
                            }
                        };
                    } else { button.className += ' bg-gray-600 opacity-50'; button.disabled = true; }
                }
                itemDiv.append(infoDiv, button); upgradesContent.appendChild(itemDiv);
            });
        }

        function checkCollision() {
            if (dx === 0 && dy === 0) return;
            for (let i = 1; i < snake.length; i++) { if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) { gameOver(); return; } }
            for (const obstacle of obstacles) {
                if (obstacle.state === 'red') {
                    for (const part of obstacle.parts) {
                        if (snake[0].x === part.x && snake[0].y === part.y) {
                            gameOver();
                            return;
                        }
                    }
                }
            }
        }

        function gameOver() { isGameOver = true; clearInterval(gameLoop); clearInterval(obstacleSpawnTimer); finalScoreElement.textContent = sessionRedAppleCount; gameOverMessage.classList.remove('hidden'); }

        function changeDirection(event) {
            if (changingDirection) return;
            const keyPressed = event.keyCode;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if (dx === 0 && dy === 0 && keyPressed === 37) {
                return;
            }
            
            if ((keyPressed === 37 && !goingRight) ||
                (keyPressed === 38 && !goingDown) ||
                (keyPressed === 39 && !goingLeft) ||
                (keyPressed === 40 && !goingUp)) {
                changingDirection = true;
                if (keyPressed === 37) { dx = -1; dy = 0; }
                if (keyPressed === 38) { dx = 0; dy = -1; }
                if (keyPressed === 39) { dx = 1; dy = 0; }
                if (keyPressed === 40) { dx = 0; dy = 1; }
            }
        }
        
        function handleTouchControls(dir) {
            if (changingDirection) return;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;
            
            if (dx === 0 && dy === 0 && dir === 'left') {
                return;
            }

            if ((dir === 'left' && !goingRight) ||
                (dir === 'up' && !goingDown) ||
                (dir === 'right' && !goingLeft) ||
                (dir === 'down' && !goingUp)) {
                changingDirection = true;
                if (dir === 'up') { dx = 0; dy = -1; }
                if (dir === 'down') { dx = 0; dy = 1; }
                if (dir === 'left') { dx = -1; dy = 0; }
                if (dir === 'right') { dx = 1; dy = 0; }
            }
        }

        restartButton.addEventListener('click', startGame);
        restartButtonGameOver.addEventListener('click', startGame);
        shopButton.addEventListener('click', () => { gameOverMessage.classList.add('hidden'); skinsTabButton.click(); shopMenu.classList.remove('hidden'); });
        backToGameOverButton.addEventListener('click', () => { shopMenu.classList.add('hidden'); gameOverMessage.classList.remove('hidden'); });
        skinsTabButton.addEventListener('click', () => {
            skinsTabButton.classList.add('active'); upgradesTabButton.classList.remove('active');
            skinsContent.classList.remove('hidden'); upgradesContent.classList.add('hidden');
            populateShopSkins();
        });
        upgradesTabButton.addEventListener('click', () => {
            upgradesTabButton.classList.add('active'); skinsTabButton.classList.remove('active');
            upgradesContent.classList.remove('hidden'); skinsContent.classList.add('hidden');
            populateUpgrades();
        });
        
        document.addEventListener('keydown', changeDirection);
        ['upBtn', 'downBtn', 'leftBtn', 'rightBtn'].forEach(id => {
            document.getElementById(id).addEventListener('click', () => handleTouchControls(id.replace('Btn', '')));
        });

        startGame();
    </script>

</body>
</html>
